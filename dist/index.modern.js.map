{"version":3,"file":"index.modern.js","sources":["../src/provider.ts","../src/lib.ts","../src/routes.ts"],"sourcesContent":["import { JungleBusClient } from \"@gorillapool/js-junglebus\";\nimport * as Client from \"bitcoin-core\";\nimport fetch from \"cross-fetch\";\nimport createError, { NotFound } from \"http-errors\";\nimport { Redis } from \"ioredis\";\n\nlet redis: Redis;\nif (process.env.REDIS_HOST) {\n  const host = process.env.REDIS_HOST;\n  const port = process.env.REDIS_PORT\n    ? parseInt(process.env.REDIS_PORT, 10)\n    : 6379;\n  console.log(\"Connecting to redis:\", host, port);\n  redis = new Redis(port, host);\n}\n\nexport interface ITxProvider {\n  network: string;\n  getRawTx: (string) => Promise<Buffer>;\n  getBlockchainInfo: () => Promise<{ height: number; hash: string }>;\n  getBlockByHeight: (number) => Promise<{ height: number; hash: string }>;\n  getBlockByHash: (string) => Promise<{ height: number; hash: string }>;\n}\n\nexport class RpcProvider implements ITxProvider {\n  private client: Client;\n\n  constructor(\n    public network: string,\n    host: string,\n    port: string,\n    username: string,\n    password: string\n  ) {\n    this.client = new Client({\n      host,\n      port,\n      username,\n      password,\n    });\n  }\n\n  async getRawTx(txid: string): Promise<Buffer> {\n    let rawtx = await redis?.getBuffer(`rawtx:${txid}`);\n    if (!rawtx) {\n      rawtx = await this.client.getTransactionByHash(txid, {\n        extension: \"bin\",\n      });\n      if (!rawtx) {\n        throw new NotFound();\n      }\n      redis?.set(`rawtx:${txid}`, rawtx);\n    }\n    return rawtx;\n  }\n\n  async getBlockchainInfo(): Promise<{ height: number; hash: string }> {\n    const info = await this.client.getBlockchainInfo();\n    return {\n      height: info.blocks,\n      hash: info.bestblockhash,\n    };\n  }\n\n  async getBlockByHeight(\n    height: number\n  ): Promise<{ height: number; hash: string }> {\n    const hash = await this.client.getBlockHash(height);\n    return { height, hash };\n  }\n\n  async getBlockByHash(\n    hash: string\n  ): Promise<{ height: number; hash: string }> {\n    const info = await this.client.getBlockHeader(hash);\n    return {\n      height: info.height,\n      hash,\n    };\n  }\n}\n\nexport class JungleBusProvider implements ITxProvider {\n  public network = \"bsv\";\n\n  async getRawTx(txid: string): Promise<Buffer> {\n    let rawtx = await redis?.getBuffer(`rawtx:${txid}`);\n    if (!rawtx) {\n      const jb = new JungleBusClient(\"https://junglebus.gorillapool.io\");\n      const txnData = await jb.GetTransaction(txid);\n      rawtx = Buffer.from(txnData!.transaction, \"base64\");\n      redis?.set(`rawtx:${txid}`, rawtx);\n    }\n    return rawtx;\n  }\n\n  async getBlockchainInfo(): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      \"https://api.whatsonchain.com/v1/bsv/main/block/headers\"\n    );\n    if (!resp.ok) {\n      throw createError(resp.status, resp.statusText);\n    }\n    const info = await resp.json();\n    return {\n      height: info[0].height,\n      hash: info[0].hash,\n    };\n  }\n\n  async getBlockByHeight(\n    height: number\n  ): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      `https://api.whatsonchain.com/v1/bsv/main/block/height/${height}`\n    );\n    const info = await resp.json();\n    return { height, hash: info.hash };\n  }\n\n  async getBlockByHash(\n    hash: string\n  ): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      `https://api.whatsonchain.com/v1/bsv/main/block/hash/${hash}`\n    );\n    const info = await resp.json();\n\n    return {\n      height: info.height,\n      hash,\n    };\n  }\n}\n\nexport class BtcProvider implements ITxProvider {\n  public network = \"btc\";\n\n  async getRawTx(txid: string): Promise<Buffer> {\n    let rawtx = await redis?.getBuffer(`rawtx:${txid}`);\n    if (!rawtx) {\n      // TODO: Make this configuration based\n      const resp = await fetch(\n        `https://ordinals.shruggr.cloud/v1/btc/tx/${txid}`\n      );\n      if (!resp.ok) {\n        throw createError(resp.status, resp.statusText);\n      }\n      rawtx = Buffer.from(await resp.arrayBuffer());\n      redis?.set(`rawtx:${txid}`, rawtx);\n    }\n    return rawtx;\n  }\n\n  async getBlockchainInfo(): Promise<{ height: number; hash: string }> {\n    // TODO: Make this configuration based\n    const resp = await fetch(\n      \"https://ordinals.shruggr.cloud/v1/btc/block/latest\"\n    );\n    if (!resp.ok) {\n      throw createError(resp.status, resp.statusText);\n    }\n\n    return resp.json();\n  }\n\n  async getBlockByHeight(\n    height: number\n  ): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      `https://ordinals.shruggr.cloud/v1/btc/block/height/${height}`\n    );\n    const info = await resp.json();\n    return { height, hash: info.hash };\n  }\n\n  async getBlockByHash(\n    hash: string\n  ): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      `https://ordinals.shruggr.cloud/v1/btc/block/hash/${hash}`\n    );\n    const info = await resp.json();\n\n    return {\n      height: info.height,\n      hash,\n    };\n  }\n}\n","import { OpCode, Script, Tx } from \"@ts-bitcoin/core\";\nimport { Transaction } from \"bitcore-lib\";\nimport * as dns from \"dns/promises\";\nimport { NotFound } from \"http-errors\";\nimport fetch from \"cross-fetch\";\nimport {\n  BtcProvider,\n  ITxProvider,\n  JungleBusProvider,\n  RpcProvider,\n} from \"./provider\";\n\nconst B = Buffer.from(\"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\");\nconst ORD = Buffer.from(\"ord\");\n\nlet btcProvider: ITxProvider = new BtcProvider();\nlet bsvProvider: ITxProvider = new JungleBusProvider();\n\nif (process.env.BITCOIN_HOST) {\n  bsvProvider = new RpcProvider(\n    \"bsv\",\n    process.env.BITCOIN_HOST || \"\",\n    process.env.BITCOIN_PORT || \"8332\",\n    process.env.BITCOIN_USER || \"\",\n    process.env.BITCOIN_PASS || \"\"\n  );\n}\n\nif (process.env.BTC_HOST) {\n  btcProvider = new RpcProvider(\n    \"btc\",\n    process.env.BTC_HOST || \"\",\n    process.env.BTC_PORT || \"8332\",\n    process.env.BTC_USER || \"\",\n    process.env.BTC_PASS || \"\"\n  );\n}\n\nexport async function getLatestBlock(\n  network: string\n): Promise<{ height: number; hash: string }> {\n  switch (network) {\n    case \"btc\":\n      return btcProvider.getBlockchainInfo();\n    case \"bsv\":\n      return bsvProvider.getBlockchainInfo();\n    default:\n      throw new NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function getBlockByHeight(\n  network: string,\n  height: number\n): Promise<{ height: number; hash: string }> {\n  switch (network) {\n    case \"btc\":\n      return btcProvider.getBlockByHeight(height);\n    case \"bsv\":\n      return bsvProvider.getBlockByHeight(height);\n    default:\n      throw new NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function getBlockByHash(\n  network: string,\n  hash: string\n): Promise<{ height: number; hash: string }> {\n  switch (network) {\n    case \"btc\":\n      return btcProvider.getBlockByHash(hash);\n    case \"bsv\":\n      return bsvProvider.getBlockByHash(hash);\n    default:\n      throw new NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function getRawTx(\n  network: string,\n  txid: string\n): Promise<Buffer | undefined> {\n  switch (network) {\n    case \"btc\":\n      return btcProvider.getRawTx(txid);\n    case \"bsv\":\n      return bsvProvider.getRawTx(txid);\n    default:\n      throw new NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function loadPointerFromDNS(hostname: string): Promise<string> {\n  const lookupDomain = `_ordfs.${hostname}`;\n  const TXTs = await dns.resolveTxt(lookupDomain);\n  const prefix = \"ordfs=\";\n  let pointer = \"\";\n  console.log(\"Lookup Up:\", lookupDomain);\n  outer: for (const TXT of TXTs) {\n    for (const elem of TXT) {\n      if (!elem.startsWith(prefix)) continue;\n      console.log(\"Elem:\", elem);\n      pointer = elem.slice(prefix.length);\n      console.log(\"Origin:\", pointer);\n      break outer;\n    }\n\n    if (!pointer) {\n      throw new NotFound();\n    }\n  }\n  return pointer;\n}\n\nexport async function loadInscription(pointer: string, metadata = false): Promise<File> {\n  console.log(\"loadInscription\", pointer);\n  let file: File | undefined;\n  if (pointer.match(/^[0-9a-fA-F]{64}_\\d*$/)) {\n    const [txid, vout] = pointer.split(\"_\");\n    console.log(\"BSV:\", txid, vout);\n    const rawtx = await bsvProvider.getRawTx(txid);\n    if (!rawtx) throw new Error(\"No raw tx found\");\n    const tx = Tx.fromBuffer(rawtx);\n    const v = parseInt(vout, 10);\n    const script = tx.txOuts[v].script;\n    if (!script) throw new NotFound();\n    file = parseScript(script);\n    if (file && metadata) {\n      try {\n        const url =`https://ordinals.gorillapool.io/api/inscriptions/outpoint/${pointer}`;\n        const resp = await fetch(url);\n        const data = await resp.json();\n        const { hash } = await bsvProvider.getBlockByHeight(data!.height);\n        const meta: Meta = {\n          height: data.height,\n          MAP: data.MAP,\n          hash,\n          txid,\n          v,\n        };\n        file.meta = meta;\n      } catch {};\n    }\n  } else if (pointer.match(/^[0-9a-fA-F]{64}i\\d+$/) && btcProvider) {\n    const [txid, vin] = pointer.split(\"i\");\n    console.log(\"BTC\", txid, vin);\n    const rawtx = await btcProvider.getRawTx(txid);\n    if (!rawtx) throw new Error(\"No raw tx found\");\n    const tx = new Transaction(rawtx);\n    const script = Script.fromBuffer(tx.inputs[parseInt(vin, 10)].witnesses[1]);\n    if (!script) throw new NotFound();\n    file = parseScript(script);\n  } else throw new Error(\"Invalid Pointer\");\n\n  if (!file) throw new NotFound();\n  return file;\n}\n\nexport interface Meta {\n  height?: number;\n  hash?: string;\n  txid: string;\n  v: number;\n  MAP?: {[key:string]:any}\n}\n\nexport interface File {\n  type: string;\n  data: Buffer;\n  meta?: Meta;\n}\n\nexport interface OrdFS {\n  [filename: string]: string;\n}\n\nexport function parseScript(script: Script): File | undefined {\n  let opFalse = 0;\n  let opIf = 0;\n  let opORD = 0;\n\n  let type = \"application/octet-stream\";\n  let data = Buffer.alloc(0);\n  for (const [i, chunk] of script.chunks.entries()) {\n    if (chunk.buf?.equals(B) && script.chunks.length > i + 2) {\n      data = script.chunks[i + 1].buf!;\n      type = script.chunks[i + 2].buf!.toString();\n      return { data, type };\n    }\n    if (chunk.opCodeNum === OpCode.OP_FALSE) {\n      opFalse = i;\n    }\n    if (chunk.opCodeNum === OpCode.OP_IF) {\n      opIf = i;\n    }\n    if (chunk.buf?.equals(ORD) && opFalse === i - 2 && opIf === i - 1) {\n      opORD = i;\n      break;\n    }\n  }\n\n  for (let i = opORD + 1; i < script.chunks.length; i++) {\n    switch (script.chunks[i].opCodeNum) {\n      case OpCode.OP_FALSE:\n        while (\n          script.chunks[i + 1]?.opCodeNum >= 1 &&\n          script.chunks[i + 1]?.opCodeNum <= OpCode.OP_PUSHDATA4\n        ) {\n          data = Buffer.concat([data, script.chunks[i + 1].buf!]);\n          i++;\n        }\n        break;\n      case 1:\n        // treat 1 like OP_1 (BTC convention)\n        // console.log(script.chunks[i].toString('hex'))\n        if (script.chunks[i].buf![0] != 1) return;\n      case OpCode.OP_TRUE:\n        type = script.chunks[i + 1]!.buf!.toString(\"utf8\");\n        // console.log(\"Type:\", type)\n        i++;\n        break;\n      case OpCode.OP_ENDIF:\n        return { type, data };\n      default:\n        return;\n    }\n  }\n\n  return { type, data };\n}\n","import * as express from \"express\";\nimport { Response } from \"express\";\nimport { NotFound } from \"http-errors\";\nimport {\n  File,\n  OrdFS,\n  getBlockByHash,\n  getBlockByHeight,\n  getLatestBlock,\n  getRawTx,\n  loadInscription,\n  loadPointerFromDNS,\n} from \"./lib\";\n\nfunction sendFile(file: File, res: Response, immutable = true) {\n  res.header(\"Content-Type\", file.type || \"\");\n  if (file.meta) {\n    res.header('ordfs-meta', JSON.stringify(file.meta))\n  }\n  if (immutable && !file.meta) {\n    res.header(\"Cache-Control\", \"public,immutable,max-age=31536000\");\n  }\n  res.status(200).send(file.data);\n}\n\nexport function RegisterRoutes(app: express.Express) {\n  app.get(\"/\", async (req, res) => {\n    let outpoint: string;\n    try {\n      outpoint = await loadPointerFromDNS(req.hostname);\n    } catch (e: any) {\n      // DNS pointer not found\n      res.render(\"pages/index\");\n      return;\n    }\n    try {\n      const file = await loadInscription(outpoint);\n      if (file.type === \"ord-fs/json\" && !req.query[\"raw\"]) {\n        req.res?.redirect(\"index.html\");\n        return;\n      }\n      sendFile(file, res, false);\n    } catch (err) {\n      // TODO: inscription not found\n      res.render(\"pages/404\");\n    }\n  });\n\n  app.get(\"/v1/:network/block/latest\", async (req, res, next) => {\n    try {\n      res.json(await getLatestBlock(req.params.network));\n    } catch (e) {\n      next(e);\n    }\n  });\n\n  app.get(\"/v1/:network/block/height/:height\", async (req, res, next) => {\n    try {\n      res.json(\n        await getBlockByHeight(\n          req.params.network,\n          parseInt(req.params.height, 10)\n        )\n      );\n    } catch (e) {\n      next(e);\n    }\n  });\n\n  app.get(\"/v1/:network/block/hash/:hash\", async (req, res, next) => {\n    try {\n      res.json(await getBlockByHash(req.params.network, req.params.hash));\n    } catch (e) {\n      next(e);\n    }\n  });\n\n  app.get(\"/v1/:network/tx/:txid\", async (req, res) => {\n    res.set(\"Content-type\", \"application/octet-stream\");\n    res.send(await getRawTx(req.params.network, req.params.txid));\n  });\n  app.get(\"/:filename\", getInscriptionOrDnsFile);\n  app.get(\"/content/:pointer\", getInscription);\n  app.get(\"/preview/:b64HtmlData\", previewHtmlFromB64Data);\n  app.get(\"/:pointer/:filename\", getOrdfsFile);\n  app.get(\"/content/:pointer/:filename\", getOrdfsFile);\n\n  async function previewHtmlFromB64Data(req, res, next) {\n    try {\n      const b64HtmlData = req.params.b64HtmlData;\n      const htmlData = Buffer.from(b64HtmlData, \"base64\").toString(\"utf8\");\n      res.render(\"pages/preview\", { htmlData });\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async function getInscriptionOrDnsFile(req, res, next) {\n    const filename = req.params.filename;\n    try {\n      let pointer: string;\n      let file: File;\n      let immutable = true;\n      try {\n        // check if its an ordfs directory\n        file = await loadInscription(filename, req.query.meta);\n        if (file.type === \"ord-fs/json\" && !req.query.raw) {\n          req.res?.redirect(`/${filename}/index.html`);\n          return;\n        }\n      } catch (e: any) {\n        console.error(\"Outpoint Error\", filename, e.message);\n        pointer = await loadPointerFromDNS(req.hostname);\n        const dirData = await loadInscription(pointer);\n        const dir = JSON.parse(dirData.data!.toString(\"utf8\"));\n        if (!dir[filename]) {\n          throw new NotFound();\n        }\n        pointer = dir[filename].slice(6);\n        file = await loadInscription(pointer, req.query.meta);\n        immutable = false;\n      }\n      sendFile(file, res, immutable);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async function getInscription(req, res, next) {\n    const pointer = req.params.pointer;\n    try {\n      const file = await loadInscription(pointer, req.query.meta);\n      // check if its an ordfs directory\n      if (file.type === \"ord-fs/json\" && !req.query.raw) {\n        req.res?.redirect(`/${pointer}/index.html`);\n        return;\n      }\n      sendFile(file, res, true);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async function getOrdfsFile(req, res, next) {\n    try {\n      let pointer = req.params.pointer;\n      const filename = req.params.filename;\n      const dirData = await loadInscription(pointer);\n      const dir: OrdFS = JSON.parse(dirData.data!.toString(\"utf8\"));\n      if (!dir[filename]) {\n        throw new NotFound();\n      }\n      if (dir[filename].startsWith(\"ord://\")) {\n        pointer = dir[filename].slice(6);\n      } else {\n        pointer = dir[filename];\n      }\n      const file = await loadInscription(pointer, req.query.meta);\n      sendFile(file, res, true);\n    } catch (err) {\n      next(err);\n    }\n  }\n}\n"],"names":["redis","process","env","REDIS_HOST","host","port","REDIS_PORT","parseInt","console","log","Redis","RpcProvider","constructor","network","username","password","client","this","Client","getRawTx","txid","_redis","rawtx","getBuffer","_redis2","getTransactionByHash","extension","NotFound","set","getBlockchainInfo","info","height","blocks","hash","bestblockhash","getBlockByHeight","getBlockHash","getBlockByHash","getBlockHeader","B","Buffer","from","ORD","btcProvider","_redis5","_redis6","resp","fetch","ok","createError","status","statusText","arrayBuffer","json","bsvProvider","_redis3","_redis4","jb","JungleBusClient","txnData","GetTransaction","transaction","async","getLatestBlock","loadPointerFromDNS","hostname","lookupDomain","TXTs","dns","resolveTxt","pointer","outer","TXT","elem","startsWith","slice","prefix","loadInscription","metadata","file","match","vout","split","Error","tx","Tx","fromBuffer","v","script","txOuts","parseScript","url","data","meta","MAP","_unused","vin","Transaction","Script","inputs","witnesses","opFalse","opIf","opORD","type","alloc","i","chunk","chunks","entries","_chunk$buf","_chunk$buf2","buf","equals","length","toString","opCodeNum","OpCode","OP_FALSE","OP_IF","_script$chunks","_script$chunks2","OP_PUSHDATA4","concat","OP_TRUE","OP_ENDIF","sendFile","res","immutable","header","JSON","stringify","send","RegisterRoutes","app","getOrdfsFile","req","next","params","filename","dirData","dir","parse","query","err","get","outpoint","e","render","_req$res","redirect","_req$res2","raw","error","message","_req$res3","htmlData","b64HtmlData","BITCOIN_HOST","BITCOIN_PORT","BITCOIN_USER","BITCOIN_PASS","BTC_HOST","BTC_PORT","BTC_USER","BTC_PASS"],"mappings":"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"}